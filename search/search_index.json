{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"How to Approach This Guide","text":""},{"location":"#balancing-theory-with-practice","title":"Balancing Theory with Practice","text":"<p>This guide is taught to give you the concepts and tools to solve real  science problems through the guide. In this way you can learn the concepts  and get experience at the same time.</p>"},{"location":"#suggested-progression-through-the-guide","title":"Suggested Progression Through the Guide","text":"<p>My suggestion is to learn following the table of contents, but if you have  some experience you can start where you want, or you can read only the  theoretical part of the guide.  </p>"},{"location":"#table-of-contents","title":"Table of Contents","text":""},{"location":"#introduction-to-programming-for-science","title":"Introduction to Programming for Science","text":"<ul> <li>What is Programming in Scientific Contexts?<ul> <li>Historical Perspective of Scientific Computing</li> <li>Key Differences Between General and Scientific Programming</li> </ul> </li> <li>Computational Thinking and Problem-Solving<ul> <li>Breaking Down Problems</li> <li>Designing Logical Solutions</li> </ul> </li> <li>Overview of Programming Languages for Science<ul> <li>Python, our main focus</li> <li>Other important programming languages (we will integrate them later)<ul> <li>MATLAB: </li> <li>Julia:</li> <li>C/C++:</li> <li>Mathematica:</li> </ul> </li> </ul> </li> <li>Career Paths in Scientific Programming<ul> <li>Roles and Skills in Academia, Industry, and Government</li> <li>Building a Portfolio for Scientific Software Development</li> </ul> </li> </ul>"},{"location":"#setting-up-your-first-programming-environment","title":"Setting Up Your First Programming Environment","text":"<ul> <li>Choosing the Right Tools for Scientific Programming<ul> <li>Criteria for Selecting Languages and Libraries</li> <li>Overview of Integrated Development Environments (IDEs)</li> </ul> </li> <li>Editors and IDEs: Recommendations and Configurations</li> <li>Running Your First Program<ul> <li>Command Line Basics</li> <li>Writing and Running Scripts</li> </ul> </li> </ul>"},{"location":"#foundational-programming-concepts","title":"Foundational Programming Concepts","text":"<ul> <li>Variables and Data Types<ul> <li>Primitive Types and Memory Management</li> <li>Type Conversion and Casting</li> </ul> </li> <li>Basic Operations<ul> <li>Arithmetic Operations</li> <li>Logical and Bitwise Operations</li> </ul> </li> <li>Input and Output <ul> <li>Reading from Standard Input</li> <li>Writing to Console and Files</li> <li>Formatting Output for Scientific Notation </li> </ul> </li> <li>Control Flow<ul> <li>Conditional Statements</li> <li>Looping Structures</li> <li>Using Break, Continue, and Pass</li> </ul> </li> <li>Modular Programming<ul> <li>Writing Function</li> <li>Scope and Lifetime of Variables</li> </ul> </li> <li>Tools for Scientific Programming<ul> <li>Managing Dependencies and Libraries</li> <li>Introduction to Build Systems</li> <li>Cloud-Based Tools and Platforms </li> </ul> </li> <li>Installing Essential Tools<ul> <li>Installing Version Control Systems (e.g., Git)</li> <li>Setting Up a Virtual Environment (Python, Conda, etc.)</li> </ul> </li> <li>Debugging and Error Handling<ul> <li>Understanding Syntax vs. Logical Errors</li> <li>Tools for Debugging (e.g., Debuggers, Print Statements)</li> <li>Writing Robust Code with Exception Handling</li> </ul> </li> <li>Introduction to Algorithms<ul> <li>Basic Sorting and Searching Algorithms</li> <li>Algorithmic Thinking for Scientific Applications</li> <li>Trade-Offs in Time and Space Complexity</li> </ul> </li> </ul>"},{"location":"#working-with-data-and-data-structures","title":"Working with Data and Data Structures","text":"<ul> <li>Fundamental Data Structures<ul> <li>Lists and Arrays</li> <li>Dictionaries and Hash Maps for Key-Value Storage</li> <li>Sets and Tuples</li> <li>Nested Data Structures</li> </ul> </li> <li>Advanced Data Structures<ul> <li>Linked Lists, Stacks, and Queues</li> <li>Trees and Graphs</li> <li>Implementing Custom Data Structures</li> </ul> </li> <li>Manipulating Arrays and Matrices<ul> <li>Matrix Algebra and Scientific Applications</li> <li>Operations on Sparse and Dense Matrices</li> <li>Broadcasting and Vectorized Operations</li> </ul> </li> <li>File Handling<ul> <li>Reading and Writing Text Files</li> <li>Binary File Operations and Data Serialization</li> </ul> </li> <li>Parsing and Managing Scientific Data<ul> <li>CSV, JSON, and XML Formats</li> <li>python libs: pandas and Dask</li> </ul> </li> </ul>"},{"location":"#scientific-visualization","title":"Scientific Visualization","text":"<ul> <li>Principles of Effective Scientific Communication<ul> <li>Choosing the Right Visual Representation</li> <li>Avoiding Misleading Graphs and Bias</li> </ul> </li> <li>Basic Plotting Techniques<ul> <li>Line Plots, Scatter Plots, and Histograms</li> <li>Customizing Axes, Legends, and Labels</li> </ul> </li> <li>Common visualization tools<ul> <li>Matplotlib</li> <li>plotly</li> <li>seaborn</li> <li>ROOT</li> <li>ggPlot</li> </ul> </li> </ul>"},{"location":"#intermediate-programming-topics","title":"Intermediate Programming Topics","text":"<ul> <li>Functional Programming Concepts<ul> <li>Lambda Functions for Concise Operations</li> <li>Higher-Order Functions (Map, Reduce, Filter)</li> <li>Recursion: Concepts, Examples, and Limitations</li> </ul> </li> <li>Object-Oriented Programming (OOP)<ul> <li>Understanding Classes and Objects</li> <li>Constructors, Methods, and Attributes</li> <li>Inheritance and Polymorphism</li> <li>Encapsulation and Abstraction</li> </ul> </li> <li>Regular Expressions<ul> <li>Pattern Matching Basics</li> <li>Applications in Parsing and Text Manipulation</li> </ul> </li> <li>Intermediate File Handling<ul> <li>Working with Compressed Files (e.g., ZIP, GZIP)</li> <li>Reading and Writing Streams for Real-Time Data</li> <li>Specialized Scientific Formats: HDF5, NetCDF, and FITS</li> <li>Managing Large Data Files Efficiently</li> </ul> </li> <li>Scientific Libraries and Frameworks<ul> <li>Organizing Code into Modules and Packages</li> <li>Documentation for Modular Code</li> <li>Overview of Popular Libraries for Data Analysis and Visualization</li> <li>Integrating Scientific Libraries into Workflows</li> </ul> </li> <li>Introduction to Scripting for Automation<ul> <li>Automating File and Data Processing</li> <li>Scheduling and Managing Automated Tasks</li> </ul> </li> </ul>"},{"location":"#numerical-methods-and-linear-algebra","title":"Numerical Methods and Linear Algebra","text":"<ul> <li>Libraries to help you<ul> <li>Numpy</li> <li>SciPy</li> </ul> </li> <li>Fundamentals of Numerical Computing<ul> <li>Understanding Floating-Point Representation</li> <li>Sources of Errors: Round-Off and Truncation</li> </ul> </li> <li>Solving Linear Systems<ul> <li>Direct Methods: Gaussian Elimination and LU Decomposition</li> <li>Iterative Methods: Jacobi and Gauss-Seidel</li> </ul> </li> <li>Root-Finding Techniques<ul> <li>Graphical Methods for Root Estimation</li> <li>Numerical Techniques: Bisection, Newton-Raphson, Secant</li> </ul> </li> <li>Numerical Differentiation and Integration<ul> <li>Finite Difference Approximation</li> <li>Trapezoidal and Simpson\u2019s Rule</li> <li>Adaptive Quadrature</li> </ul> </li> <li>Eigenvalues and Eigenvectors<ul> <li>Computation and Applications</li> <li>Power Method and QR Algorithm</li> </ul> </li> <li>Introduction to Sparse Matrices<ul> <li>Storage Formats: COO, CSR, and CSC</li> <li>Solving Large Sparse Systems</li> <li>Applications in Graph Theory and Network Analysis</li> </ul> </li> </ul>"},{"location":"#computational-efficiency-and-optimization","title":"Computational Efficiency and Optimization","text":"<ul> <li>Profiling and Optimizing Code<ul> <li>Identifying Bottlenecks</li> <li>Using Profilers to Improve Performance</li> </ul> </li> <li>Writing Efficient Algorithms<ul> <li>Big-O Notation and Complexity Analysis</li> <li>Strategies for Improving Efficiency</li> </ul> </li> <li>Memory Management<ul> <li>Stack and Heap Allocation</li> <li>Optimizing Memory Usage</li> </ul> </li> <li>Parallel Computing<ul> <li>Introduction to Threads and Processes</li> <li>Using OpenMP and MPI for Distributed Computing</li> <li>GPU Computing Basics: CUDA and OpenCL</li> </ul> </li> <li>Vectorization and Broadcasting<ul> <li>Techniques for Array-Based Programming</li> <li>Performance Benefits in Numerical Computation</li> </ul> </li> <li>Optimization Techniques<ul> <li>Local and Global Optimization</li> <li>Applications of Optimization in Science and Engineering</li> </ul> </li> </ul>"},{"location":"#advanced-visualization","title":"Advanced Visualization","text":"<ul> <li>Advanced plots<ul> <li>Multiple plots</li> <li>3D Plotting: Surfaces, Wireframes, and Volumes</li> <li>Interactive Visualizations with Tools like Plotly or Bokeh</li> </ul> </li> <li>Visualizing Large Datasets<ul> <li>Strategies for Down-sampling and Aggregation</li> <li>Specialized Tools for Big Data Visualization</li> </ul> </li> <li>Creating Publication-Ready Graphics<ul> <li>Exporting High-Resolution Images</li> <li>Styling Guidelines for Journals and Conferences</li> </ul> </li> </ul>"},{"location":"#advanced-topics-in-scientific-computing","title":"Advanced Topics in Scientific Computing","text":"<ul> <li>Symbolic Computing<ul> <li>Simplifying Expressions and Solving Equations</li> <li>Applications in Differential Equations and Integration</li> </ul> </li> <li>Solving Differential Equations<ul> <li>Ordinary Differential Equations (ODEs): Euler and Runge-Kutta Methods</li> <li>Partial Differential Equations (PDEs): Finite Difference and Finite Element Methods</li> <li>Boundary Value Problems</li> </ul> </li> <li>Advanced Numerical Methods<ul> <li>Spectral Methods for Signal and Function Analysis</li> <li>Multigrid Methods for Faster Convergence</li> </ul> </li> <li>High-Performance Computing (HPC)<ul> <li>Supercomputing Architectures</li> <li>Writing Scalable Parallel Programs</li> <li>Case Studies in HPC for Science </li> </ul> </li> </ul>"},{"location":"#machine-learning","title":"Machine Learning","text":"<ul> <li>Machine Learning for Scientific Applications<ul> <li>Basics of Supervised and Unsupervised Learning</li> <li>Neural Networks for Scientific Data</li> <li>Physics-Informed Machine Learning Models</li> </ul> </li> <li>Libraries<ul> <li>scikit-learn</li> <li>TensorFlow</li> <li>PyTorch</li> </ul> </li> </ul>"},{"location":"#collaboration-and-reproducibility","title":"Collaboration and Reproducibility","text":"<ul> <li>Writing Reproducible Code<ul> <li>Best Practices for Version Control</li> <li>Documenting Code for Collaboration</li> </ul> </li> <li>Reproducible Research<ul> <li>Combining Code, Data, and Results</li> <li>Tools for Reproducible Workflows (e.g., Jupyter, RMarkdown)</li> </ul> </li> <li>Teamwork in Scientific Programming<ul> <li>Managing Contributions with Git and GitHub</li> <li>Resolving Conflicts in Collaborative Projects</li> </ul> </li> </ul>"},{"location":"#emerging-technologies-in-scientific-computing","title":"Emerging Technologies in Scientific Computing","text":"<ul> <li>Keeping Up with Trends<ul> <li>Joining Scientific Programming Communities</li> <li>Staying Updated with Research and Tools</li> </ul> </li> <li>Basics of Quantum Computing</li> <li>Cloud-Based Scientific Workflows</li> <li>Integrating Blockchain for Data Integrity</li> </ul>"},{"location":"#additional-considerations","title":"Additional Considerations","text":"<ul> <li>Ethics in Scientific Programming<ul> <li>Ensuring Data Privacy and Security</li> <li>Addressing Bias in Algorithms</li> </ul> </li> </ul>"},{"location":"001_What%27s_scientific_programming/","title":"What is Programming in Scientific Contexts?","text":""},{"location":"001_What%27s_scientific_programming/#historical-perspective-of-scientific-computing","title":"Historical Perspective of Scientific Computing","text":"<p>Programming in scientific contexts has played a transformative role in  modern science. Its roots trace back to the mid-20th century, during the  rapid development of early computing machines. One of the most notable  milestones was the advent of ENIAC (1945), one of the first general-purpose electronic computers. ENIAC\u2019s  primary goal was to solve numerical problems, particularly for military  applications such as calculating artillery trajectories for thermonuclear  weapons.  However, it quickly became evident that computers could serve a far broader purpose.</p> <p>The development of programming languages tailored to scientific needs began  in the 1950s, spearheaded by the creation of <code>Fortran</code> (Formula  Translation). Fortran was, at the time, revolutionary: providing a way for  scientists and engineers to write programs that closely mirrored the  mathematical formulas they worked with daily. This innovation enabled  researchers to shift from manual calculations to automated processes,  solving problems of unprecedented complexity.</p> <p>As computing power grew exponentially, so did the scope of scientific  programming. The introduction of high-level languages, numerical libraries,  and supercomputers allowed scientists to tackle vast problems, from  modeling planetary systems to simulating nuclear reactions. </p>"},{"location":"001_What%27s_scientific_programming/#key-achievements-of-scientific-programming","title":"Key achievements of scientific programming","text":"<p>Today, scientific programming is at the heart of nearly every field of  science and engineering. Here are some examples in various fields of science.</p>"},{"location":"001_What%27s_scientific_programming/#space-exploration-and-astrophysics","title":"Space Exploration and Astrophysics","text":"<ul> <li>Apollo Guidance Computer (1969): The Apollo program used custom-designed  software to guide spacecraft to the Moon and back. The onboard computer    performed real-time calculations for navigation and landing, a    monumental achievement for the time.</li> <li>Simulations of the Universe: Projects like the Millennium Simulation    modeled the large-scale structure of the universe, helping    astrophysicists understand galaxy formation and the role of dark matter.</li> <li>Black Hole Imaging (2019): Computational algorithms were key to producing    the first-ever image of a black hole by the Event Horizon Telescope.</li> </ul>"},{"location":"001_What%27s_scientific_programming/#climate-modeling","title":"Climate Modeling","text":"<ul> <li>General Circulation Models (GCMs): These simulations predict climate  patterns by solving equations for atmospheric and oceanic dynamics. Early models were pivotal in understanding the greenhouse effect, while modern GCMs are used to project the impacts of climate change.</li> <li>Global Weather Prediction: Tools like the European Centre for Medium-Range    Weather Forecasts (ECMWF) model provide accurate weather predictions, saving lives during extreme weather events.</li> <li>Arctic Ice Loss Studies: Supercomputers model the interactions between the    ocean, atmosphere, and ice sheets to forecast sea-level rise and its global implications.</li> </ul>"},{"location":"001_What%27s_scientific_programming/#physics-and-particle-simulations","title":"Physics and Particle Simulations","text":"<ul> <li>Manhattan Project (1940s): Early computational methods were used to  simulate nuclear chain reactions, a crucial step in developing nuclear technology.</li> <li>CERN\u2019s Large Hadron Collider (2012): Discovering the Higgs boson relied    heavily on data analysis pipelines capable of processing petabytes of    information. </li> <li>Quantum Simulations: Quantum computers and high-performance simulations    are now used to model complex quantum systems, paving the way for    advancements in materials science and quantum technologies.</li> </ul>"},{"location":"001_What%27s_scientific_programming/#medicine-and-biology","title":"Medicine and Biology","text":"<ul> <li>Human Genome Project (2003): Computational algorithms for DNA sequencing  and assembly enabled the mapping of the human genome, revolutionizing genetics and personalized medicine.</li> <li>Drug Discovery: Computational methods like molecular docking simulate how    drugs interact with target proteins, accelerating the development of treatments for diseases such as COVID-19.</li> <li>Protein Folding: Projects like AlphaFold (2020) by DeepMind used machine    learning to predict protein structures with high accuracy, solving a decades-old challenge in biology.</li> </ul>"},{"location":"001_What%27s_scientific_programming/#engineering-and-fluid-dynamics","title":"Engineering and Fluid Dynamics","text":"<ul> <li>Aerodynamics of Aircraft: Computational Fluid Dynamics (CFD) simulations  are used to optimize the design of aircraft and spacecraft, reducing drag and improving fuel efficiency.</li> <li>Bridge and Skyscraper Design: Structural simulations predict how buildings    respond to stresses like wind and earthquakes, ensuring safety and reliability.</li> <li>Automotive Crash Testing: Computational simulations help test car designs    under collision scenarios, reducing the need for physical prototypes and enhancing safety standards.</li> </ul>"},{"location":"001_What%27s_scientific_programming/#computer-science-and-ai","title":"Computer Science and AI","text":"<ul> <li>Deep Learning and Neural Networks: The development of frameworks like  TensorFlow and PyTorch enabled breakthroughs in artificial intelligence, from image recognition to natural language processing.</li> <li>Chess and Go (AlphaZero, 2018): Computational algorithms defeated human    world champions by learning optimal strategies for complex games entirely from scratch.</li> <li>GPT Models (e.g., ChatGPT): Large-scale natural language models like GPT    have transformed how we interact with technology, using massive datasets and neural networks to simulate human-like responses.</li> </ul>"},{"location":"001_What%27s_scientific_programming/#economic-and-social-sciences","title":"Economic and Social Sciences","text":"<ul> <li>Agent-Based Modeling: Simulations of social behavior and economic systems  provide insights into phenomena such as financial market dynamics.</li> <li>Urban Planning: Computational models analyze traffic flows, energy    consumption, and infrastructure needs to design smarter, more sustainable cities.</li> </ul>"},{"location":"001_What%27s_scientific_programming/#key-differences-between-general-and-scientific-programming","title":"Key Differences Between General and Scientific Programming","text":""},{"location":"001_What%27s_scientific_programming/#purpose","title":"Purpose","text":"<p>The fundamental goals of general and scientific programming differ significantly:</p> <ul> <li>General Programming focuses on creating software systems, applications, and  tools designed for user interaction, entertainment, productivity, or commercial use. Examples include web applications, mobile apps, and games. The emphasis is often on usability, scalability, and user experience.</li> <li>Scientific Programming is primarily concerned with    solving computational problems specific to scientific disciplines such as physics, chemistry, biology, and engineering. The objective is to model, simulate, or analyze phenomena, often pushing the boundaries of our understanding of the natural world.</li> </ul> <p>For instance, while a general programmer might build a user-friendly photo-sharing app, a scientific programmer might simulate the trajectory of a spacecraft or analyze genome sequences to identify mutations.</p>"},{"location":"001_What%27s_scientific_programming/#algorithm-design","title":"Algorithm Design","text":"<p>Scientific programming demands the creation or implementation of algorithms tailored to specific scientific problems such as:</p> <ul> <li>Differential Equations: Modeling phenomena such as heat transfer, orbital mechanics, or population dynamics.</li> <li>Optimization: Solving problems like minimizing energy states in physical systems or training machine learning models.</li> <li>Statistical Analysis: Processing and interpreting experimental data.</li> </ul> <p>In contrast, general programming algorithms often deal with functionality like search, sorting, data structure manipulation, or ensuring the responsiveness of applications.</p>"},{"location":"001_What%27s_scientific_programming/#testing-and-validation","title":"Testing and Validation","text":"<p>Scientific programming requires rigorous testing to ensure results align with theoretical predictions or empirical data.</p> <p>In general programming, testing primarily ensures software functionality and user experience.</p>"},{"location":"001_What%27s_scientific_programming/#reproducibility","title":"Reproducibility","text":"<p>Reproducibility is a cornerstone of scientific programming:</p> <ul> <li>Version Control: Tools like Git are essential for tracking changes and collaborating on research projects.</li> <li>Open-Source Practices: Sharing code, data, and methodologies to ensure other researchers can verify or build upon work.</li> <li>Containerization: Docker and similar tools are increasingly used to create reproducible computational environments.</li> </ul> <p>While reproducibility is also important in general programming (e.g., version control in development), the emphasis is more on iterative improvements and deployment.</p>"},{"location":"001_What%27s_scientific_programming/#lifecycles-and-longevity","title":"Lifecycles and Longevity","text":"<p>Scientific programs often have long lifespans, requiring maintainability for decades:</p> <ul> <li>Legacy systems, like Fortran codes written in the 1970s, are still widely used in fields like weather prediction and computational physics.</li> <li>Scientific programs may be iteratively improved but often focus on stability and correctness over frequent feature updates.</li> </ul> <p>General programming often has shorter lifecycles, particularly for commercial applications, which are regularly replaced or rewritten to meet changing user demands.</p>"},{"location":"001_What%27s_scientific_programming/#community-and-collaboration","title":"Community and Collaboration","text":"<ul> <li>Scientific Programming: Collaboration across disciplines is common. Physicists, chemists, and engineers often work together, sharing domain knowledge to achieve complex goals.</li> <li>General Programming: Collaboration typically focuses on team-based software development, involving designers, developers, and business analysts.</li> </ul>"},{"location":"001_What%27s_scientific_programming/#ethical-considerations","title":"Ethical Considerations","text":"<p>Scientific programming often involves addressing global challenges, such as climate change or public health, which carry profound ethical implications: - Ensuring accurate and unbiased simulations for policymaking. - Avoiding misuse of scientific models, such as weaponizing computational advances. (I'm looking at you engeneer who accepted that job to build missiles)</p> <p>In general programming, ethical considerations often focus on user privacy, data security, and fair algorithms for public-facing applications.</p>"},{"location":"001_What%27s_scientific_programming/#learning-curves-and-background-knowledge","title":"Learning Curves and Background Knowledge","text":"<ul> <li>Scientific programming often requires more understanding of the underlying mathematical and physical principles than the programming skills itself.</li> <li>General programming typically emphasizes mastery of software development practices, user interfaces, and system design, which may not require domain-specific knowledge.</li> </ul>"},{"location":"002_Computational_Thinking/","title":"Computational Thinking and Problem-Solving","text":""},{"location":"002_Computational_Thinking/#breaking-down-problems","title":"Breaking Down Problems","text":"<p>In scientific programming, computational problems are typically derived from physical laws or empirical data. The process involves:     1.  Problem Definition: Understand the scientific problem (e.g., modeling planetary motion or solving a heat equation).     2.  Mathematical Modeling: Formulate equations or algorithms that represent the problem.     3.  Abstraction: Simplify the problem into computationally manageable parts, identifying input parameters, boundary conditions, and outputs.     4.  Decomposition: Break the problem into smaller sub-problems, each solvable with code.</p>"},{"location":"002_Computational_Thinking/#designing-logical-solutions","title":"Designing Logical Solutions","text":"<p>Logical solution design involves:     1.  Algorithm Selection: Choose methods appropriate for the problem (e.g., finite difference for partial differential equations).     2.  Validation: Check solutions against known results or experimental data.     3.  Optimization: Improve algorithm performance using parallel computing, optimized libraries, or better mathematical techniques.     4.  Reproducibility: Ensure the solution can be reliably reproduced by others using documentation, version control, and standard file formats.</p> <p>For instance, in Python, NumPy provides robust methods for linear algebra, while SciPy extends these capabilities to optimization and integration problems, all essential in computational thinking.</p>"},{"location":"003_Overview_of_programming_languages/","title":"Overview of Programming Languages","text":"<p>There are a lot of programming languages out there, every one of them with  their pros and cons, in this guide we will focus on <code>python</code>, but in this  page we will also talk a little about: <code>Fortran</code>, <code>C</code>, <code>C++</code>, <code>R</code>, <code>MATLAB</code>,  <code>Mathematica (wolfram)</code>, <code>Julia</code>. </p> <p>During the first part of the course we will  forget  about those languages, we will talk about them later we will need to  integrate advanced tools in our projects.</p> <p>We will not discuss other languages.</p> Honorable mentions: <p>There are some cool programming languages out there like:  <code>Assembly</code>,  <code>Haskell</code>, <code>Rust</code> <code>Java</code> (not honorable but I have to cite it) and <code>brainfuck</code>. </p>"},{"location":"003_Overview_of_programming_languages/#why-python","title":"Why python?","text":"<p>Let me explain why I choose phyton as the main focus of this guide. I will  explain with an example.</p> <p>Let's imagine we want to calculate the trajectory of a free-falling body, in  particular we want to calculate the time of flight, the maximum height and  the horizontal distance given: the initial velocity, the initial angle and  the gravitational acceleration.</p> <p>We will create a file called <code>input.txt</code> where we will write our initial  parameters.</p> input.txt <pre><code>velocity: 30\nangle: 45\ngravity: 9.8\n</code></pre> <p>We will now want to create a program to read the file and solve our problem,  below are 7 solutions in different languages.</p> <p>Solutions</p> pythonC++MATLABFortranJuliaMathematicaR example.py<pre><code>import math\n\n# calculate trajectory parameters\ndef calculate_projectile(velocity, angle_deg, gravity):\n    angle_rad = math.radians(angle_deg)\n\n    time_of_flight = (2 * velocity * math.sin(angle_rad)) / gravity\n\n    max_height = (velocity**2 * math.sin(angle_rad)**2) / (2 * gravity)\n\n    horizontal_distance = (velocity**2 * math.sin(2 * angle_rad)) / gravity\n\n    return time_of_flight, max_height, horizontal_distance\n\n# Read inputs from file\ninput_file = 'input.txt'\ntry:\n    with open(input_file, 'r') as file:\n        data = file.readlines()\n        inputs = {}\n        for line in data:\n            key, value = line.split(':')\n            inputs[key.strip()] = float(value.strip())\n\n    # Extract values from input dictionary\n    velocity = inputs['velocity']\n    angle = inputs['angle']\n    gravity = inputs['gravity']\n\n    # Calculate results\n    time_of_flight, max_height, horizontal_distance = calculate_projectile(velocity, angle, gravity)\n\n    # Print results\n    print(f\"Time of Flight: {time_of_flight:.2f} seconds\")\n    print(f\"Maximum Height: {max_height:.2f} meters\")\n    print(f\"Horizontal Distance: {horizontal_distance:.2f} meters\")\n\nexcept FileNotFoundError:\n    print(f\"Error: Input file '{input_file}' not found.\")\n</code></pre> <p>Run:</p> <pre><code>python example.py\n</code></pre> example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;cmath&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\n// Function to calculate the projectile motion\nvoid calculateProjectile(double velocity, double angle_deg, double gravity,\n                         double &amp;time_of_flight, double &amp;max_height, double &amp;horizontal_distance) {\n    double angle_rad = angle_deg * M_PI / 180.0;\n\n    time_of_flight = (2 * velocity * sin(angle_rad)) / gravity;\n\n    max_height = (pow(velocity, 2) * pow(sin(angle_rad), 2)) / (2 * gravity);\n\n    horizontal_distance = (pow(velocity, 2) * sin(2 * angle_rad)) / gravity;\n}\n\nint main() {\n    // Input file name\n    string input_file = \"input.txt\";\n    ifstream infile(input_file);\n\n    if (!infile.is_open()) {\n        cerr &lt;&lt; \"Error: Unable to open input file \\\"\" &lt;&lt; input_file &lt;&lt; \"\\\".\" &lt;&lt; endl;\n        return 1;\n    }\n\n    // Read inputs\n    double velocity, angle, gravity;\n    string line;\n    while (getline(infile, line)) {\n        size_t delimiter = line.find(':');\n        string key = line.substr(0, delimiter);\n        double value = stod(line.substr(delimiter + 1));\n\n\n        if (key == \"velocity\") velocity = value;\n        else if (key == \"angle\") angle = value;\n        else if (key == \"gravity\") gravity = value;\n    }\n    infile.close();\n\n    double time_of_flight, max_height, horizontal_distance;\n\n    // Perform calculations\n    calculateProjectile(velocity, angle, gravity, time_of_flight, max_height, horizontal_distance);\n\n    // Output results\n    cout &lt;&lt; \"Time of Flight: \" &lt;&lt; time_of_flight &lt;&lt; \" seconds\" &lt;&lt; endl;\n    cout &lt;&lt; \"Maximum Height: \" &lt;&lt; max_height &lt;&lt; \" meters\" &lt;&lt; endl;\n    cout &lt;&lt; \"Horizontal Distance: \" &lt;&lt; horizontal_distance &lt;&lt; \" meters\" &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>Compilation:</p> <pre><code>g++ -o example example.cpp\n</code></pre> <p>Execution:</p> <pre><code>./example\n</code></pre> example.m<pre><code>input_file = 'input.txt';\n\n% Read the file\ntry\n    fileID = fopen(input_file, 'r');\n    data = textscan(fileID, '%s %f', 'Delimiter', ':');\n    fclose(fileID);\n\n    % Parse inputs\n    inputs = containers.Map(data{1}, data{2});\n    velocity = inputs('velocity');\n    angle = inputs('angle');\n    gravity = inputs('gravity');\n\n    angle_rad = deg2rad(angle);\n\n    time_of_flight = (2 * velocity * sin(angle_rad)) / gravity;\n\n    max_height = (velocity^2 * (sin(angle_rad)^2)) / (2 * gravity);\n\n    horizontal_distance = (velocity^2 * sin(2 * angle_rad)) / gravity;\n\n    % Display results\n    fprintf('Time of Flight: %.2f seconds\\n', time_of_flight);\n    fprintf('Maximum Height: %.2f meters\\n', max_height);\n    fprintf('Horizontal Distance: %.2f meters\\n', horizontal_distance);\n\ncatch ME\n    fprintf('Error reading or processing the input file: %s\\n', ME.message);\nend\n</code></pre> <p>Run (in MATLAB or Octave):</p> <pre><code>example\n</code></pre> example.f90<pre><code>program projectile\n    implicit none\n\n    real(8) :: velocity, angle, gravity\n    real(8) :: time_of_flight, max_height, horizontal_distance\n    character(len=100) :: line\n    integer :: iunit, ios\n    character(len=20) :: key\n    real(8) :: value\n\n    open(unit=iunit, file='input.txt', status='old')\n\n    ! Read the input file line by line\n    do\n        read(iunit,'(A)', i=1) line\n        if (line == '') exit\n\n        read(line, '(A:F)', iunit=ios, i=1) key, value\n        select case (key)\n        case (\"velocity\")\n            velocity = value\n        case (\"angle\")\n            angle = value\n        case (\"gravity\")\n            gravity = value\n        end select\n    end do\n    close(iunit)\n\n    ! Perform calculations\n    time_of_flight = (2.0 * velocity * sin(angle * 3.141592653589793 / 180.0)) / gravity\n    max_height = (velocity**2 * sin(angle * 3.141592653589793 / 180.0)**2) / (2.0 * gravity)\n    horizontal_distance = (velocity**2 * sin(2.0 * angle * 3.141592653589793 / 180.0)) / gravity\n\n    ! Output results\n    print *, 'Time of Flight: ', time_of_flight, ' seconds'\n    print *, 'Maximum Height: ', max_height, ' meters'\n    print *, 'Horizontal Distance: ', horizontal_distance, ' meters'\n\nend program projectile\n</code></pre> <p>Compilation:</p> <pre><code>gfortran -o example example.f90\n</code></pre> <p>Execution:</p> <pre><code>./example\n</code></pre> example.jl<pre><code># Function to calculate projectile motion\nfunction calculate_projectile(velocity, angle_deg, gravity)\n    angle_rad = deg2rad(angle_deg)\n\n    time_of_flight = (2 * velocity * sin(angle_rad)) / gravity\n\n    max_height = (velocity^2 * sin(angle_rad)^2) / (2 * gravity)\n\n    horizontal_distance = (velocity^2 * sin(2 * angle_rad)) / gravity\n\n    return time_of_flight, max_height, horizontal_distance\nend\n\n# Read input from file\nfunction read_input(file_name)\n    inputs = Dict{String, Float64}()\n    open(file_name, \"r\") do f\n        for line in eachline(f)\n            parts = split(line, \":\")\n            key = strip(parts[1])\n            value = parse(Float64, strip(parts[2]))\n            inputs[key] = value\n        end\n    end\n    return inputs\nend\n\ninput_file = \"input.txt\"\ninputs = read_input(input_file)\n\n# Extract values\nvelocity = inputs[\"velocity\"]\nangle = inputs[\"angle\"]\ngravity = inputs[\"gravity\"]\n\n# Perform calculations\ntime_of_flight, max_height, horizontal_distance = calculate_projectile(velocity, angle, gravity)\n\n# Output results\nprintln(\"Time of Flight: \", time_of_flight, \" seconds\")\nprintln(\"Maximum Height: \", max_height, \" meters\")\nprintln(\"Horizontal Distance: \", horizontal_distance, \" meters\")\n</code></pre> <p>Run:</p> <pre><code>julia example.jl\n</code></pre> example.wls<pre><code>(* Function to calculate projectile motion *)\ncalculateProjectile[velocity_, angle_, gravity_] := Module[\n  {timeOfFlight, maxHeight, horizontalDistance, angleRad},\n\n  angleRad = AngleUnit -&gt; Degree;\n\n  timeOfFlight = (2 velocity Sin[angle]) / gravity;\n\n  maxHeight = (velocity^2 Sin[angle]^2) / (2 gravity);\n\n  horizontalDistance = (velocity^2 Sin[2 angle]) / gravity;\n\n  {timeOfFlight, maxHeight, horizontalDistance}\n]\n\n(* Function to read inputs from file *)\nreadInput[file_] := Module[\n  {lines, inputs},\n  lines = ReadList[file, String];\n  inputs = Association[];\n  Do[\n    (* Parse key-value pairs from each line *)\n    inputs[key] = ToExpression[StringDrop[lines[[i]], 1]],\n    {i, Length[lines]},\n    {key, StringTake[lines[[i]], {1, 7}]}\n  ];\n  inputs\n]\n\n(* Main program *)\n\n(* Read input file *)\ninputFile = \"input.txt\";\ninputs = readInput[inputFile];\n\n(* Extract values *)\nvelocity = inputs[\"velocity\"];\nangle = inputs[\"angle\"];\ngravity = inputs[\"gravity\"];\n\n(* Perform calculations *)\n{timeOfFlight, maxHeight, horizontalDistance} = calculateProjectile[velocity, angle, gravity];\n\n(* Output results *)\nPrint[\"Time of Flight: \", timeOfFlight, \" seconds\"];\nPrint[\"Maximum Height: \", maxHeight, \" meters\"];\nPrint[\"Horizontal Distance: \", horizontalDistance, \" meters\"];\n</code></pre> <p>Run:</p> <pre><code>math -script example.wls\n</code></pre> example.R<pre><code># Function to calculate projectile motion\ncalculate_projectile &lt;- function(velocity, angle_deg, gravity) {\n  # Convert angle to radians\n  angle_rad &lt;- angle_deg * pi / 180\n\n  time_of_flight &lt;- (2 * velocity * sin(angle_rad)) / gravity\n\n  max_height &lt;- (velocity^2 * sin(angle_rad)^2) / (2 * gravity)\n\n  horizontal_distance &lt;- (velocity^2 * sin(2 * angle_rad)) / gravity\n\n  return(list(time_of_flight = time_of_flight, \n              max_height = max_height, \n              horizontal_distance = horizontal_distance))\n}\n\n# Function to read input from file\nread_input &lt;- function(file_name) {\n  lines &lt;- readLines(file_name)\n\n  # Extract key-value pairs\n  inputs &lt;- sapply(lines, function(line) {\n    parts &lt;- strsplit(line, \":\")[[1]]\n    key &lt;- trimws(parts[1])\n    value &lt;- as.numeric(trimws(parts[2]))\n    return(value)\n  })\n\n  # Return a named list\nreturn(setNames(as.list(inputs), c(\"velocity\", \"angle\", \"gravity\")))\n}\n\n# Main program\ninput_file &lt;- \"input.txt\"\n\n# Read inputs\ninputs &lt;- read_input(input_file)\n\n# Perform calculations\nresults &lt;- calculate_projectile(inputs$velocity, inputs$angle, inputs$gravity)\n\n# Print results\ncat(\"Time of Flight:\", results$time_of_flight, \"seconds\\n\")\ncat(\"Maximum Height:\", results$max_height, \"meters\\n\")\ncat(\"Horizontal Distance:\", results$horizontal_distance, \"meters\\n\")\n</code></pre> <p>Run:</p> <pre><code>Rscript example.R\n</code></pre> If you cannot understand the code <p>If it's the first time seeing source code don't worry, it's like trying  to understand some phrases in a language that you don't know, what do  you expect? Learning to code is a slow process, you will be able to understand  everything step by step following this guide.</p> <p>As you can see each language has a different syntax, from the seven the  most intuitive language is python (with julia and R pretty colse). That's  the main reason why this guide is in python it is easy to read.</p>"},{"location":"003_Overview_of_programming_languages/#pros-and-cons-of-python","title":"Pros and cons of python","text":""},{"location":"003_Overview_of_programming_languages/#pros","title":"Pros","text":"<ul> <li>Ease of Learning: Python's simple syntax makes it beginner-friendly.</li> <li>Versatility: Wide applicability in web development, data science, machine learning, automation, and more.</li> <li>Large Ecosystem: Extensive libraries and frameworks (e.g., NumPy, pandas, TensorFlow, Flask, Django).</li> <li>Cross-Platform: Works seamlessly across multiple operating systems.</li> <li>Community Support: Large and active community ensures plenty of resources and troubleshooting support.</li> <li>Interpreted Language: Eliminates the need for compilation, facilitating rapid development and testing.</li> <li>Dynamic Typing: Allows flexibility in variable usage without strict type declarations.</li> <li>Integration Capability: Easily integrates with other languages like C, C++, and Java.</li> <li>Readable Code: Emphasizes code readability, which is critical for collaborative projects.</li> <li>Strong Support for Automation: Simplifies scripting and task automation.</li> </ul>"},{"location":"003_Overview_of_programming_languages/#cons","title":"Cons","text":"<ul> <li>Slower Execution: Interpreted nature and dynamic typing can make it slower compared to compiled languages like C++ or Java.</li> <li>High Memory Usage: May not be suitable for memory-intensive tasks.</li> <li>Weak in Mobile Development: Limited adoption for mobile application development.</li> <li>Runtime Errors: Dynamic typing can lead to runtime errors that might be caught earlier in statically typed languages.</li> <li>GIL (Global Interpreter Lock): Limits the performance of multithreaded Python programs, especially in CPU-bound tasks.</li> <li>Version Compatibility Issues: Migration between Python 2 and Python 3 caused fragmentation; legacy issues may persist.</li> <li>Not Ideal for Low-Level Programming: Less efficient for tasks requiring direct interaction with hardware.</li> </ul>"},{"location":"003_Overview_of_programming_languages/#lets-talk-about-the-others","title":"Let's talk about the others","text":"<p><code>C</code>: A low-level, efficient, and widely-used programming language for system programming, embedded systems, and performance-critical applications.</p> <p><code>C++</code>: An extension of C, adding object-oriented programming, templates, and modern programming paradigms, used for high-performance applications.</p> <p><code>Fortran</code>: A high-performance language for scientific and numerical computing, particularly in physics, engineering, and computational simulations.</p> <p><code>R</code>: A language designed for statistical analysis and data visualization, widely used in data science and research.</p> <p><code>MATLAB</code>: A high-level language and environment for numerical computing, data analysis, and visualization, popular in engineering and scientific domains.</p> <p><code>Mathematica</code>: A symbolic computation and numerical analysis tool with powerful capabilities for algebra, calculus, and advanced scientific visualization.</p> <p><code>Julia</code>: A modern, high-performance language designed for numerical and scientific computing, offering simplicity and speed.</p>"},{"location":"004_Careers/","title":"Career Paths in Scientific Programming","text":""},{"location":"004_Careers/#roles-and-skills-in-academia-industry-and-government","title":"Roles and Skills in Academia, Industry, and Government","text":"<pre><code>\u2022   Academia:\n\u2022   Role: Research Scientist, Computational Physicist\n\u2022   Skills: Numerical modeling, high-performance computing, advanced algorithm design\n\u2022   Industry:\n\u2022   Role: Data Scientist, Simulation Engineer\n\u2022   Skills: Machine learning, software development, integration of computational tools into pipelines\n\u2022   Government:\n\u2022   Role: Research Analyst, Policy Advisor\n\u2022   Skills: Data analysis, large-scale simulations (e.g., climate or epidemiological models)\n</code></pre>"},{"location":"004_Careers/#building-a-portfolio-for-scientific-software-development","title":"Building a Portfolio for Scientific Software Development","text":"<pre><code>\u2022   Project Work: Showcase projects that solve specific problems, such as simulating physical systems or analyzing experimental data.\n\u2022   Documentation: Write clear, well-structured code with comprehensive documentation.\n\u2022   Version Control: Use GitHub or GitLab to demonstrate collaboration and version control proficiency.\n\u2022   Publication: Share work through papers or open-source repositories.\n\u2022   Continued Learning: Stay updated on programming advancements and scientific tools like Docker for reproducibility or HPC clusters for large-scale computations.\n</code></pre>"}]}